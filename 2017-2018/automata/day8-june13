Last class was a test

At this point we have established 3 mechanisms (4 if you include the systems of
equations thing) that are the same class of lanaguage (regular langugage) but
there is a 5th


Regular Languages:
    DFA
    NFA
    System of Equations
    regular expressions
    Regular Grammars

Context Free grammar:
    G = (N, T, P, S)

        Where N is the alphabet of variables
        T is the alphabet of terminals
            We assume that N and T have nothing in common (a terminal cannot 
            be a variable)

        S is in N and is known as the starting symbol

        P is a finite set of productions

            What is a production? An element of N :cross: ( N :union: T)*

            WHich is a string across both terminals and variables
            Formally written as

            A -> :alpha:



            How do we do this? We obviously have variables (which tend to dget
            replaced).  A production is basically a scheme to replace a
            variable.  We do this by taking a variable and replacing it with
            what is on the other side of the production that we are going to
            apply


    Example:
        N = {S}
        T = {a, b}
        P = {S -> aSa | b}
            Technically written,
                S -> aSa
                S -> b
            he just shorthanded it

        One variable, with two symbols (the variable has to be the starting
        symbol)

        So now we start with the starting symbol, and then we can replace it
        with stuff that is on the right hand side of production.

        So if we had S we could replace it with b
        or we could take the S and replace it by aSa, and then we could replace
        that S by b, which would give us aba.
        Or we can replace the S by aSa again, and keep doing this..

        {a^n b a^n | n >= 0}


    our definition of a context free grammar 
        (N :union: T)* :cross: (N :union: T)*

Convention for regular languages
    a, b, c, ... terminals in T

    u, v, w, x, y, z are words from the terminals in T*
        (cannot contain variables)

    A, B, C, ... Variables, elements of N

    :alpha:, :beta:, ... -> Strings over N :union: T
        elements of (N :union: T)*
        They can contain terminals, variabels, everything in the kitchen


    Now we see the meaning of A -> :alpha:


Now we will take our grammar:
    P = {S -> aSa | b}

    and use SabSSabSbS as our alpha, so we want to see what we can derie


    iff :alpha: = :alpha1: A :alpha2: and A -> :gamma: which is a subset of P,
    and :beta: = :alpha1: :gamma: :alpha2:

    THis is the definition of derives.  How many strings can we get from this?
    THe answer is 10.  FOr each S, we can replace it either by aSa or b.  So
    since there are 5 S's, we can replace each of those S's by one of two
    things, one at a time.  So there are 10 possible new strings that we could
    end up with based on our production

    We will apply our production 0 or more times, because we can ontinually
    replace as long as we have a variable.

    THis then gives us:
        The lanaguage generated by the context free grammar g(N, T, P, S) is
                        *
        L(G) = { w | S -> w}

                w such that we can derive w in one or more steps.

                w is a string over the terminls T, expressed by our convention

            We start with the starting symbol, and have to kill off all
            variables.


WHat does context free mean?
    our variable is replaced no matter how it is encountered, the lanaguge is
    independent of the context in which the variable is encountered

The first thing we should do, is look at context free grammars and restrict
them:
    A Regular grammar, G, is a context free grammar in which all productions
    are of the form
        A -> a  or A -> aB

    We basically are restricting A -> :alpha: to variable goes to a single
    terminal or goes to a single terminal followed by a variable

    Now the question is what kind of a language do we get when we look at a
    regulr grammar?

    S -> a | bS | bA
    A -> b | bB
    B -> aS

    we can construct an automaton from this

    S is the inital state, and can transition to a, or can be replaced by bS,
    which would loop back to itself

    REgular grammar is a subset of context free grammar.  All regular grammars
    are a context free grammar.  Not all context free grammars are regular
    grammars

    After we get to the final state we expect nothing more, the grammar should
    be definied such that we end up in the final state only if we have nothing
    else and are supposed to end in the final state

    We have shown that any regular language can be converted into a finite
    automaton

The set of all regular languages is a subset of the set of all context free
languages

Regular grammars are a little bit limited:
    They obviously cannot generate the empty word

    Not every regular lenguage is generated by a regular grammar.  Every
    regular language that does not contain the empty word can be represented by
    a regular grammar.


WHen we deal with regular languages, we are not really interested with the
empty word. What we are going to show is two Normal forms:
    Normal Form:
        A restriction on the form of the produtions, but a restriction that
        does not limit the powerof the grammar.

    Normal form types:
        Chonsky Normal Form (CNF)
            You can restric yoself to A -> or A -> BC

            A variable is replaced with either a single terminal or exactly two
            variables.

            Suspiciously for what we definied for regular grammars.
                A -> a or A -> aB
            Any context free grammar that does not generate epsilon, can be
            converted into a grammar of Chonsky Normal Form

        Gribach Normal Form (GNF)
            Any variable can be replaced by the right hand side of the
            production, which is a single terminal followed by 0 or more
            variables

            A -> a B1, ..., Bn
                n >= 0

            A grammar generates things, in the case of a regular grammar it is
            nice because every production starts with a terminal.  So if you
            want to go to an atuomaton (where we have to consume a letter at
            every state) it is convientient, because we will be told what
            letter we accept


            Then length of the word tells us how many steps we need.  Because
            each step consumes a letter

        Cannot generate empty word with either of these languages


If you can't remove all of the varibles, your language is empty - you
are left with the empty language

leftmost derivation:
    We only mess with the left most variable

    which means in our original description, :alpha1: cannot contain any
    variables. When youhave ocmplicated productions with more than one variable
    then this is important.




    If you can end up with multiple end states, or end expressions, the gramar
    is known as ambigious. While this is not that bad for regular languages in
    general, it is a problem when constructing a compiler
